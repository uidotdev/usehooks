---
templateKey: post
title: useMemoCompare
date: "2020-04-08"
gist: https://gist.github.com/gragland/ca6806dbb849efa32be8a6919e281d09
links:
  - url: https://github.com/facebook/react/issues/14476
    name: useEffect custom comparator
    description: Related discussion in the React Github repo that has other potential solutions
code: "import React, { useState, useEffect, useRef } from 'react';\r\n\r\n\/\/ Usage\r\nfunction MyComponent({ obj }) {\r\n  const [state, setState] = useState();\r\n  \r\n  \/\/ We want the previous obj if obj.id is the same as the new obj.id\r\n  \/\/ We pass a custom equality function as the second arg to our hook.\r\n  const theObj = useMemoCompare(obj, prev => prev && prev.id === obj.id);\r\n  \r\n  \/\/ Here we want to fire off an effect if theObj changes.\r\n  \/\/ If we had used obj directly without the above hook and obj was technically a\r\n  \/\/ new object on every render then the effect would fire on every render.\r\n  \/\/ Worse yet, if our effect triggered a state change it could cause an endless loop.\r\n  \/\/ (effect runs -> state change causes rerender -> effect runs -> etc ...)\r\n  useEffect(() => {\r\n    \/\/ Call a method on the object and set results to state\r\n    return theObj.someMethod().then((value) => setState(value));\r\n  }, [theObj]);\r\n  \r\n  \/\/ So why not just pass [obj.id] as dependecy array?\r\n  useEffect(() => {\r\n    \/\/ Well, then eslint-plugin-hooks would rightfully complain that obj is not in the\r\n    \/\/ dependency array. By using our hook above we are more explicit about our custom\r\n    \/\/ equality checking and can separate that concern from that of our effect logic.\r\n    return obj.someMethod().then((value) => setState(value));\r\n  }, [obj.id]);\r\n    \r\n  return <div> ... <\/div>;\r\n}\r\n  \r\n\/\/ Hook\r\nfunction useMemoCompare(value, compare) {\r\n  \/\/ Ref for storing previous value\r\n  const previousRef = useRef();\r\n  const previous = previousRef.current;\r\n\r\n  \/\/ Pass previous and new value to compare function\r\n  const isEqual = compare(previous, value);\r\n\r\n  \/\/ If not equal update previous to new value (for next render)\r\n  \/\/ and then return new new value below.\r\n  useEffect(() => {\r\n    if (!isEqual) {\r\n      previousRef.current = value;\r\n    }\r\n  });\r\n\r\n  return isEqual ? previous : value;\r\n}"
---

This hook gives us the memoized value of an object, but instead of passing an array of dependencies (like with [useMemo](https://reactjs.org/docs/hooks-reference.html#usememo)) we pass a custom compare function that gets both the previous and new value. The compare function can then compare nested properties, call object methods, or whatever else you need to do in order to determine equality. If the compare function returns true then the hook returns the old object reference.
<br/><br/>
Most of the time this hook shouldn't be necessary. Where it really comes in handy is if you want to offer a library to other developers and it would be akward to force them to always memoize a value before passing it to your library. Read through the recipe and inline comments below to get a better sense of how this all works. While this example is fairly abstract, I'll be posting a new recipe tomorrow that would have been really difficult to build without using this internally. So subscribe above or check back tomorrow ;)
